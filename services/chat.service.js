const {status} = require('http-status');
const path = require('path');
const fs = require('fs');
const {ChatGroq} = require('@langchain/groq');
const {PDFLoader} = require('@langchain/community/document_loaders/fs/pdf');
const {TextLoader} = require('langchain/document_loaders/fs/text');
const {RecursiveCharacterTextSplitter} = require("@langchain/textsplitters");
const {PineconeEmbeddings} = require('@langchain/pinecone');
const {Pinecone: PineconeClient} = require('@pinecone-database/pinecone');
const {PineconeStore} = require('@langchain/pinecone');
const {StateGraph, END, START, MemorySaver, Annotation, MessagesAnnotation} = require('@langchain/langgraph');
const {TavilySearch} = require('@langchain/tavily');
const {ToolNode} = require('@langchain/langgraph/prebuilt');
const {tool} = require('@langchain/core/tools');
const {HumanMessage, SystemMessage, trimMessages, filterMessages} = require("@langchain/core/messages");
const {z} = require('zod');
const ApiError = require('../utils/ApiError');
const {getPetsByOwnerId} = require('./pet.service')

const memory = new MemorySaver();

const GraphState = Annotation.Root({
    messages: Annotation({
        reducer: (current, newMessage) => {
            if (current === undefined) {
                return [...newMessage];
            }
            return [...current, ...newMessage];
        }
    }),
    userId: Annotation({
        reducer: (current, newUserId) => {
            if (current === undefined) {
                return newUserId;
            }
            return current;
        }
    })
});

let workflow = null;
let vectorStore = null;
let pineconeIndex = null;
let embeddings = null;
let llm = null;

const textSplitter = new RecursiveCharacterTextSplitter({
    chunkSize: 512,
    chunkOverlap: 100,
});

const getPetsByOwnerTool = tool(async ({userId}) => {
    try {
        const results = await getPetsByOwnerId(userId);
        if (!results || !results.results || results.results.length === 0) {
            return "Hi·ªán t·∫°i b·∫°n ch∆∞a ƒëƒÉng k√Ω th√¥ng tin th√∫ c∆∞ng n√†o trong h·ªá th·ªëng. B·∫°n c√≥ mu·ªën th√™m th√¥ng tin th√∫ c∆∞ng c·ªßa m√¨nh kh√¥ng?";
        }

        const pets = results.results;

        // ‚úÖ Calculate statistics
        const totalPets = pets.length;
        const dogCount = pets.filter(pet => pet.species.toLowerCase().includes('ch√≥')).length;
        const catCount = pets.filter(pet => pet.species.toLowerCase().includes('m√®o')).length;

        // ‚úÖ Group by species for better organization
        const dogs = pets.filter(pet => pet.species.toLowerCase().includes('dog'));
        const cats = pets.filter(pet => pet.species.toLowerCase().includes('cat'));
        const others = pets.filter(pet => !pet.species.toLowerCase().includes('dog') && !pet.species.toLowerCase().includes('cat'));

        let response = `üêæ **Danh s√°ch th√∫ c∆∞ng c·ªßa b·∫°n** (${ totalPets } con)\n\n`;

        // ‚úÖ Add summary
        if (dogCount > 0 || catCount > 0) {
            const summary = [];
            if (dogCount > 0) summary.push(`${ dogCount } ch√≥`);
            if (catCount > 0) summary.push(`${ catCount } m√®o`);
            if (others.length > 0) summary.push(`${ others.length } kh√°c`);
            response += `üìä T·ªïng quan: ${ summary.join(', ') }\n\n`;
        }

        // ‚úÖ Format dogs section
        if (dogs.length > 0) {
            response += `üêï **C√ÅC B√â CH√ì (${ dogs.length } con):**\n`;
            dogs.forEach((pet, index) => {
                const age = calculateAge(pet.birthDate);
                response += `${ index + 1 }. **${ pet.name }** - ${ pet.breed } ${ pet.gender === 'male' ? '‚ôÇÔ∏è' : '‚ôÄÔ∏è' }\n`;
                response += `   üìÖ Sinh: ${ formatDate(pet.birthDate) } (${ age })\n\n`;
            });
        }

        // ‚úÖ Format cats section  
        if (cats.length > 0) {
            response += `üê± **C√ÅC B√â M√àO (${ cats.length } con):**\n`;
            cats.forEach((pet, index) => {
                const age = calculateAge(pet.birthDate);
                response += `${ index + 1 }. **${ pet.name }** - ${ pet.breed } ${ pet.gender === 'male' ? '‚ôÇÔ∏è' : '‚ôÄÔ∏è' }\n`;
                response += `   üìÖ Sinh: ${ formatDate(pet.birthDate) } (${ age })\n\n`;
            });
        }

        // ‚úÖ Format other pets
        if (others.length > 0) {
            response += `üêæ **TH√ö C∆ØNG KH√ÅC (${ others.length } con):**\n`;
            others.forEach((pet, index) => {
                const age = calculateAge(pet.birthDate);
                response += `${ index + 1 }. **${ pet.name }** - ${ pet.species } ${ pet.breed } ${ pet.gender === 'male' ? '‚ôÇÔ∏è' : '‚ôÄÔ∏è' }\n`;
                response += `   üìÖ Sinh: ${ formatDate(pet.birthDate) } (${ age })\n\n`;
            });
        }

        return response;

    } catch (error) {
        console.error('Error fetching pets:', error);
        return "Xin l·ªói, hi·ªán t·∫°i t√¥i kh√¥ng th·ªÉ l·∫•y th√¥ng tin th√∫ c∆∞ng c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau.";
    }
}, {
    name: "get_pets_by_owner",
    description: "L·∫•y th√¥ng tin danh s√°ch th√∫ c∆∞ng c·ªßa ng∆∞·ªùi d√πng c·ª• th·ªÉ v·ªõi format ƒë·∫πp v√† d·ªÖ ƒë·ªçc. S·ª≠ d·ª•ng khi kh√°ch h√†ng h·ªèi v·ªÅ th√∫ c∆∞ng c·ªßa h·ªç nh∆∞ 'th√∫ c∆∞ng c·ªßa t√¥i', 'con ch√≥/m√®o c·ªßa t√¥i', ho·∫∑c mu·ªën bi·∫øt th√¥ng tin chi ti·∫øt v·ªÅ c√°c th√∫ c∆∞ng ƒëang nu√¥i.",
    schema: z.object({
        userId: z.string().describe("ID ng∆∞·ªùi d√πng c·∫ßn l·∫•y th√¥ng tin th√∫ c∆∞ng")
    }),
});

// ‚úÖ Helper functions for formatting
const calculateAge = (birthDate) => {
    if (!birthDate) return 'Ch∆∞a r√µ tu·ªïi';

    const birth = new Date(birthDate);
    const now = new Date();
    const diffTime = Math.abs(now - birth);
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

    if (diffDays < 30) {
        return `${ diffDays } ng√†y tu·ªïi`;
    } else if (diffDays < 365) {
        const months = Math.floor(diffDays / 30);
        return `${ months } th√°ng tu·ªïi`;
    } else {
        const years = Math.floor(diffDays / 365);
        const remainingMonths = Math.floor((diffDays % 365) / 30);
        if (remainingMonths > 0) {
            return `${ years } tu·ªïi ${ remainingMonths } th√°ng`;
        }
        return `${ years } tu·ªïi`;
    }
};

const formatDate = (dateString) => {
    if (!dateString) return 'Ch∆∞a r√µ';

    const date = new Date(dateString);
    return date.toLocaleDateString('vi-VN', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    });
};

const getServicesTool = tool(async ({query, petType, priceRange}) => {
    try {
        const {getAllServices, searchServices} = require('./service.service');

        const filter = {isVisible: true};
        const options = {page: 1, limit: 6};

        if (petType) {
            filter.petTypes = {$in: [petType]};
        }

        if (priceRange) {
            const [minPrice, maxPrice] = priceRange.split('-').map(Number);
            if (minPrice) filter.price = {$gte: minPrice};
            if (maxPrice) filter.price = {...filter.price, $lte: maxPrice};
        }

        let result;

        if (query && query.trim() !== '') {
            result = await searchServices(query, filter, options);
        } else {
            result = await getAllServices(filter, options);
        }

        if (!result.results || result.results.length === 0) {
            return `Kh√¥ng t√¨m th·∫•y d·ªãch v·ª• n√†o ph√π h·ª£p v·ªõi "${ query }". Vui l√≤ng th·ª≠ t·ª´ kh√≥a kh√°c.`;
        }

        let response = `üè• **T√¨m th·∫•y ${ result.totalResults } d·ªãch v·ª• cho "${ query }"**\n\n`;

        result.results.forEach((service, index) => {
            const finalPrice = service.onSale && service.salePrice ? service.salePrice : service.price;
            const originalPrice = service.onSale && service.salePrice ? service.price : null;

            response += `${ index + 1 }. **${ service.name }**\n`;
            response += `   üí∞ Gi√°: ${ finalPrice.toLocaleString('vi-VN') }ƒë`;

            if (originalPrice) {
                response += ` (~~${ originalPrice.toLocaleString('vi-VN') }ƒë~~) üî•`;
            }

            response += `\n   ‚è∞ Th·ªùi gian: ${ service.duration } ph√∫t\n`;
            response += `   üêæ Ph√π h·ª£p: ${ service.petTypes ? service.petTypes.join(', ') : 'T·∫•t c·∫£ th√∫ c∆∞ng' }\n`;

            if (service.ratings && service.ratings.average > 0) {
                response += `   ‚≠ê ƒê√°nh gi√°: ${ service.ratings.average }/5 (${ service.ratings.count } l∆∞·ª£t)\n`;
            }

            if (service.description && service.description.length > 0) {
                const shortDesc = service.description.length > 100
                    ? service.description.substring(0, 100) + '...'
                    : service.description;
                response += `   üìù M√¥ t·∫£: ${ shortDesc }\n`;
            }

            response += '\n';
        });

        if (result.totalResults > result.results.length) {
            response += `üìù *Hi·ªÉn th·ªã ${ result.results.length }/${ result.totalResults } d·ªãch v·ª•. ƒê·ªÉ ƒë·∫∑t l·ªãch h·∫πn, vui l√≤ng cho t√¥i bi·∫øt d·ªãch v·ª• b·∫°n quan t√¢m.*`;
        }

        return response;

    } catch (error) {
        console.error('‚ùå Error in getServicesTool:', error);
        return `Xin l·ªói, hi·ªán t·∫°i t√¥i kh√¥ng th·ªÉ t√¨m ki·∫øm d·ªãch v·ª•. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá v·ªõi ch√∫ng t√¥i.`;
    }
}, {
    name: "get_services",
    description: "T√¨m ki·∫øm d·ªãch v·ª• chƒÉm s√≥c th√∫ c∆∞ng c√≥ s·∫µn v·ªõi th√¥ng tin chi ti·∫øt v·ªÅ gi√° c·∫£, th·ªùi gian v√† ƒë√°nh gi√°. S·ª≠ d·ª•ng khi kh√°ch h√†ng mu·ªën t√¨m hi·ªÉu d·ªãch v·ª•, so s√°nh gi√° c·∫£, ho·∫∑c chu·∫©n b·ªã ƒë·∫∑t l·ªãch h·∫πn.",
    schema: z.object({
        query: z.string().optional().describe("Lo·∫°i d·ªãch v·ª• c·∫ßn t√¨m (grooming, spa, kh√°m s·ª©c kh·ªèe, hu·∫•n luy·ªán, t·∫Øm g·ªôi...)"),
        petType: z.string().optional().describe("Lo√†i th√∫ c∆∞ng c·∫ßn d·ªãch v·ª• (ch√≥, m√®o, chim...)"),
        priceRange: z.string().optional().describe("Kho·∫£ng gi√° mong mu·ªën (v√≠ d·ª•: 200000-500000)")
    }),
});

const getProductsTool = tool(async ({query, category, petType, priceRange}) => {
    try {
        console.log("Hello");

        const {getAllProducts, searchProducts} = require('./product.service');

        const filter = {isVisible: true};
        const options = {page: 1, limit: 8};

        if (petType) {
            filter.petTypes = {$in: [petType]};
        }

        if (priceRange) {
            const [minPrice, maxPrice] = priceRange.split('-').map(Number);
            if (minPrice) filter.price = {$gte: minPrice};
            if (maxPrice) filter.price = {...filter.price, $lte: maxPrice};
        }

        let result;

        if (query && query.trim() !== '') {
            result = await searchProducts(query, {...filter, ...options});
        } else {
            result = await getAllProducts(filter, options);
        }

        if (!result.results || result.results.length === 0) {
            return `Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m n√†o ph√π h·ª£p v·ªõi "${ query }". Vui l√≤ng th·ª≠ t·ª´ kh√≥a kh√°c ho·∫∑c m·ªü r·ªông ti√™u ch√≠ t√¨m ki·∫øm.`;
        }

        let response = `üõçÔ∏è **T√¨m th·∫•y ${ result.totalResults } s·∫£n ph·∫©m cho "${ query }"**\n\n`;

        result.results.forEach((product, index) => {
            const finalPrice = product.onSale && product.salePrice ? product.salePrice : product.price;
            const originalPrice = product.onSale && product.salePrice ? product.price : null;

            response += `${ index + 1 }. **${ product.name }**\n`;
            response += `   üí∞ Gi√°: ${ finalPrice.toLocaleString('vi-VN') }ƒë`;

            if (originalPrice) {
                response += ` (~~${ originalPrice.toLocaleString('vi-VN') }ƒë~~) üî•`;
            }

            response += `\n   üè™ Th∆∞∆°ng hi·ªáu: ${ product.brand || 'Ch∆∞a r√µ' }\n`;
            response += `   üì¶ S·ªë l∆∞·ª£ng h√†ng: ${ product.stock > 0 ? `${ product.stock } s·∫£n ph·∫©m` : 'H·∫øt h√†ng' }\n`;

            if (product.ratings && product.ratings.average > 0) {
                response += `   ‚≠ê ƒê√°nh gi√°: ${ product.ratings.average }/5 (${ product.ratings.count } l∆∞·ª£t)\n`;
            }

            response += '\n';
        });

        if (result.totalResults > result.results.length) {
            response += `üìù *Hi·ªÉn th·ªã ${ result.results.length }/${ result.totalResults } s·∫£n ph·∫©m. H√£y c·ª• th·ªÉ h√≥a t√¨m ki·∫øm ƒë·ªÉ c√≥ k·∫øt qu·∫£ ch√≠nh x√°c h∆°n.*`;
        }

        return response;

    } catch (error) {
        console.error('‚ùå Error in getProductsTool:', error);
        return `Xin l·ªói, hi·ªán t·∫°i t√¥i kh√¥ng th·ªÉ t√¨m ki·∫øm s·∫£n ph·∫©m. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá v·ªõi ch√∫ng t√¥i.`;
    }
}, {
    name: "get_products",
    description: "T√¨m ki·∫øm s·∫£n ph·∫©m th√∫ c∆∞ng ƒë·ªÉ mua v·ªõi th√¥ng tin chi ti·∫øt v·ªÅ gi√° c·∫£, t·ªìn kho v√† ƒë√°nh gi√°. S·ª≠ d·ª•ng khi kh√°ch h√†ng mu·ªën mua s·∫£n ph·∫©m c·ª• th·ªÉ, xem gi√° c·∫£, ki·ªÉm tra t·ªìn kho ho·∫∑c so s√°nh s·∫£n ph·∫©m.",
    schema: z.object({
        query: z.string().describe("T·ª´ kh√≥a t√¨m ki·∫øm s·∫£n ph·∫©m (t√™n s·∫£n ph·∫©m, th∆∞∆°ng hi·ªáu, lo·∫°i s·∫£n ph·∫©m)"),
        petType: z.string().optional().describe("Lo√†i th√∫ c∆∞ng (ch√≥, m√®o, chim, c√°...)"),
        priceRange: z.string().optional().describe("Kho·∫£ng gi√° (v√≠ d·ª•: 100000-500000)")
    }),
});

const retrieveDocumentTool = tool(async ({query}) => {
    if (!vectorStore) {
        throw new ApiError(status.INTERNAL_SERVER_ERROR, "Vector store is not initialized");
    }
    const results = await vectorStore.similaritySearch(query, 5);
    console.log("Retrieved documents:", results);

    const result2 = results.map(doc => {
        return doc.pageContent
    })
    console.log(result2);
    return result2.join("\n\n");

}, {
    name: "retrieve_documents",
    description: "T√¨m ki·∫øm v√† tr·∫£ v·ªÅ th√¥ng tin chi ti·∫øt t·ª´ t√†i li·ªáu chuy√™n m√¥n v·ªÅ chƒÉm s√≥c th√∫ c∆∞ng, h∆∞·ªõng d·∫´n nu√¥i d∆∞·ª°ng, dinh d∆∞·ª°ng, s·ª©c kh·ªèe th√∫ c∆∞ng. S·ª≠ d·ª•ng khi c·∫ßn th√¥ng tin chuy√™n s√¢u, h∆∞·ªõng d·∫´n chi ti·∫øt ho·∫∑c l·ªùi khuy√™n t·ª´ chuy√™n gia.",
    schema: z.object({
        query: z.string().describe("The search query for retrieving documents")
    }),
});

const tools = [getPetsByOwnerTool, getServicesTool, getProductsTool, retrieveDocumentTool];
const toolNode = new ToolNode(tools);

const initRAGService = async () => {
    if (llm && vectorStore && pineconeIndex) {
        return;
    }
    llm = new ChatGroq({
        model: process.env.GROQ_MODEL || "llama-3.3-70b-versatile",
        temperature: 0.7,
    }).bindTools(tools);
    embeddings = new PineconeEmbeddings({
        model: process.env.EMBEDDING_MODEL || "multilingual-e5-large"
    });
    const pinecone = new PineconeClient();
    pineconeIndex = pinecone.Index(process.env.PINECONE_INDEX);

    vectorStore = await PineconeStore.fromExistingIndex(embeddings, {
        pineconeIndex,
        maxConcurrency: 5,
    });
}

const loadDocumentByFormat = async (filePath) => {
    const fileExtension = path.extname(filePath).toLowerCase();

    switch (fileExtension) {
        case '.pdf':
            const pdfLoader = new PDFLoader(filePath);
            return pdfLoader.load();
        case '.txt':
            const textLoader = new TextLoader(filePath);
            return textLoader.load();
        default:
            throw new ApiError(status.BAD_REQUEST, "Unsupported file format. Only PDF and TXT files are supported.");
    }
};

const indexDocument = async (file) => {
    await initRAGService();

    const fileExtension = path.extname(file.path).toLowerCase();
    if (!['.pdf', '.txt'].includes(fileExtension)) {
        throw new ApiError(status.BAD_REQUEST, "Unsupported file format. Only PDF and TXT files are supported.");
    }

    try {
        const fileName = file.originalname;
        const docs = await loadDocumentByFormat(file.path);

        docs.forEach(doc => {
            doc.metadata.fileName = fileName;
        });

        const splitDocs = await textSplitter.splitDocuments(docs);
        const batchSize = 96;
        const batches = [];

        for (let i = 0; i < splitDocs.length; i += batchSize) {
            const batch = splitDocs.slice(i, i + batchSize);
            batches.push(batch);
        }
        const docIds = [];

        await Promise.all(
            batches.map(async (batch, index) => {
                const doc = await vectorStore.addDocuments(batch);
                docIds.push(...doc);
                return doc;
            })
        );

        await Document.create({
            fileUrl: getFilePath(file),
            fileName: fileName,
            docIds: docIds,
            fileType: fileExtension === '.pdf' ? 'pdf' : 'txt'
        });

        return {
            success: true,
            fileName: fileName,
            documentCount: splitDocs.length,
            message: `Successfully indexed ${ splitDocs.length } document chunks from ${ fileName }`
        };
    } catch (error) {
        console.error("Error indexing document:", error);
        throw new ApiError(status.INTERNAL_SERVER_ERROR, `Failed to index document: ${ error.message }`);
    }
};

const agent = async (state) => {
    const {messages} = state;
    const systemMessage = new SystemMessage(`B·∫°n l√† tr·ª£ l√Ω AI cho h·ªá th·ªëng chƒÉm s√≥c th√∫ c∆∞ng.
NHI·ªÜM V·ª§: Ph√¢n t√≠ch c√¢u h·ªèi v√† quy·∫øt ƒë·ªãnh ph·∫£n h·ªìi ph√π h·ª£p.

üîç **KI·ªÇM TRA L·ªäCH S·ª¨ TR∆Ø·ªöC KHI H√ÄNH ƒê·ªòNG:**
- ƒê·ªçc to√†n b·ªô tin nh·∫Øn tr∆∞·ªõc ƒë√≥ ƒë·ªÉ xem ƒë√£ c√≥ d·ªØ li·ªáu ch∆∞a
- N·∫øu ƒë√£ c√≥ k·∫øt qu·∫£ t·ª´ tool (tin nh·∫Øn c√≥ format "üè• **T√¨m th·∫•y..." ho·∫∑c "üõçÔ∏è **T√¨m th·∫•y..."), KH√îNG g·ªçi tool n·ªØa
- Ch·ªâ g·ªçi tool khi th·ª±c s·ª± c·∫ßn d·ªØ li·ªáu m·ªõi

üìã **H∆Ø·ªöNG D·∫™N X·ª¨ L√ù:**
1. Ch√†o h·ªèi ƒë∆°n gi·∫£n (xin ch√†o, hello) ‚Üí tr·∫£ l·ªùi th√¢n thi·ªán ngay
2. ƒê√£ c√≥ d·ªØ li·ªáu trong l·ªãch s·ª≠ ‚Üí s·ª≠ d·ª•ng d·ªØ li·ªáu ƒë√≥ ƒë·ªÉ tr·∫£ l·ªùi, KH√îNG g·ªçi tool
3. C·∫ßn d·ªØ li·ªáu m·ªõi ‚Üí g·ªçi tool ph√π h·ª£p
4. Thi·∫øu th√¥ng tin ƒë·ªÉ g·ªçi tool ‚Üí h·ªèi th√™m th√¥ng tin

üõ†Ô∏è **CH·ªåN C√îNG C·ª§ KHI C·∫¶N:**
- retrieve_documents: 
  * Ki·∫øn th·ª©c chuy√™n s√¢u (b·ªánh, ƒëi·ªÅu tr·ªã, chƒÉm s√≥c, h√†nh vi, dinh d∆∞·ª°ng)
  * H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng h·ªá th·ªëng (c√°ch ƒë·∫∑t l·ªãch, c√°ch mua s·∫£n ph·∫©m, quy tr√¨nh s·ª≠ d·ª•ng)
  * C√¢u h·ªèi c√≥ t·ª´ "c√°ch", "l√†m th·∫ø n√†o", "h∆∞·ªõng d·∫´n", "quy tr√¨nh"
- get_pets_by_owner: th√∫ c∆∞ng c·ªßa ng∆∞·ªùi d√πng, ch·ªâ c·∫ßn g·ªçi khi b·∫°n c·∫ßn bi·∫øt th√∫ c∆∞ng ƒë√≥ l√† lo√†i g√¨
- get_products: t√¨m ki·∫øm danh s√°ch s·∫£n ph·∫©m c√≥ s·∫µn (query r·ªóng n·∫øu kh√¥ng n√≥i s·∫£n ph·∫©m c·ª• th·ªÉ)
- get_services: t√¨m ki·∫øm danh s√°ch d·ªãch v·ª• c√≥ s·∫µn (query r·ªóng n·∫øu kh√¥ng n√≥i d·ªãch v·ª• c·ª• th·ªÉ)

‚ö° **QUY T·∫ÆC QUAN TR·ªåNG:**
- B·∫ÆT BU·ªòC: Ch·ªâ ƒë∆∞·ª£c g·ªçi tool b·∫±ng tool_calls, TUY·ªÜT ƒê·ªêI KH√îNG vi·∫øt <function=...>{...}
- NGHI√äM C·∫§M: Kh√¥ng ƒë∆∞·ª£c tr·∫£ v·ªÅ content c√≥ d·∫°ng <function=name>{json} v√† nh·∫Øc ƒë·∫øn tool cho ng∆∞·ªùi d√πng
- N·∫æU C·∫¶N TOOL: S·ª≠ d·ª•ng tool_calls th√¥ng qua LangChain binding
- get_services: petType l√† t√πy ch·ªçn (dog/cat ho·∫∑c b·ªè tr·ªëng)
- N·∫øu ƒë√£ c√≥ danh s√°ch d·ªãch v·ª•/s·∫£n ph·∫©m, h√£y d√πng ch√∫ng ƒë·ªÉ tr·∫£ l·ªùi
- Tr·∫£ l·ªùi t·ª± nhi√™n nh∆∞ ng∆∞·ªùi t∆∞ v·∫•n th·ª±c s·ª±

üéØ **PH√ÇN BI·ªÜT INTENT:**
- "C√°ch ƒë·∫∑t l·ªãch", "l√†m th·∫ø n√†o ƒë·ªÉ...", "h∆∞·ªõng d·∫´n..." ‚Üí retrieve_documents
- "D·ªãch v·ª• n√†o c√≥ s·∫µn", "gi√° d·ªãch v·ª•", "t√¨m d·ªãch v·ª•" ‚Üí get_services
- "S·∫£n ph·∫©m n√†o c√≥", "gi√° s·∫£n ph·∫©m", "mua g√¨" ‚Üí get_products

QUAN TR·ªåNG: Khi c·∫ßn g·ªçi tool, h√£y g·ªçi tr·ª±c ti·∫øp th√¥ng qua tool_calls, KH√îNG BAO GI·ªú vi·∫øt ra text m√¥ t·∫£ vi·ªác g·ªçi tool.

üë§ User ID: ${ state.userId || 'unknown' }`);

    const response = await llm.invoke([systemMessage, ...messages.slice(-5)]);
    console.log("Response ", response);

    return {messages: [response]};
    // return {message: [...messages]}
}

const shouldContinue = (state) => {
    const {messages} = state;
    const lastMessage = messages[messages.length - 1];

    if (lastMessage.tool_calls?.length) {
        return "tools";
    }
    return END;
}

const initWorkflow = async () => {
    if (workflow) {
        return workflow;
    }
    await initRAGService();

    const graph = new StateGraph(GraphState)
        .addNode("agent", agent)
        .addNode("tools", toolNode)
        .addEdge("__start__", "agent")
        .addEdge("tools", "agent")
        .addConditionalEdges("agent", shouldContinue, {
            tools: "tools",
            __end__: END
        })

    workflow = graph.compile({
        checkpointer: memory,
    });
    return workflow;
}

const chat = async (userId, question) => {
    if (!workflow) {
        workflow = await initWorkflow();
    }

    const messages = [new HumanMessage(question)];

    const result = await workflow.invoke({messages: [...messages], userId}, {
        configurable: {
            thread_id: userId,
        }
    });
    const responseMessage = result.messages[result.messages.length - 1];

    return {
        answer: responseMessage.content,
        toolCalls: responseMessage.tool_calls || [],
    };
}

const getDocuments = async () => {
    return Document.find({}).select("-docIds")
};

const deleteDocument = async (documentId) => {
    try {
        console.log(`Deleting document with ID: ${ documentId }`);

        await initRAGService();
        const result = await Document.findOne({_id: documentId});
        if (!result) {
            throw new ApiError(status.NOT_FOUND, "Document not found");
        }
        await vectorStore.delete({ids: result.docIds});
        await Document.deleteOne({_id: documentId});
        deleteFile(result.fileUrl);
        return {success: true, message: "Document deleted successfully"};
    } catch (error) {
        console.error("Error deleting document:", error);
        throw new ApiError(status.INTERNAL_SERVER_ERROR, `Failed to delete document: ${ error.message }`);
    }
}

module.exports = {
    indexDocument,
    chat,
    getDocuments,
    deleteDocument,
}